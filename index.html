<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Timers</title>

  <style>
    :root {
      --displayw: 80px;
      --gap: 5px;
      --indent: calc(var(--displayw) + (2 * var(--gap)));
    }

    body {
      font-family: Arial, sans-serif;
      font-size: 15px;
      margin: 5px;
    }

    input, button, textarea {
      font-family: Arial, sans-serif;
      font-size: 15px;
    }

    /* Remove number input spinners */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    #timers {
      overflow-x: visible;
    }

    .timer-row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      margin-bottom: 5px;
      user-select: none;
      flex-wrap: nowrap; /* desktop unchanged */
    }

    .display {
      font-size: 20px;
      margin-right: var(--gap);
      min-width: var(--displayw);
      text-align: right;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .name {
      width: 100px;
      box-sizing: border-box;
    }

    .num {
      width: 25px;
      box-sizing: border-box;
    }

    .delay {
      width: 37.5px;
      box-sizing: border-box;
    }

    .cb {
      width: 25px;
      height: 25px;
      margin: 0;
    }

    /* Session + Import UI */
    .session-row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      margin-bottom: 10px;
      user-select: none;
      flex-wrap: nowrap;
    }

    /* ---------------- MOBILE ---------------- */
    @media (max-width: 700px) {

      .timer-row {
        flex-wrap: wrap;

        /* indent wrapped rows so they align with name */
        padding-left: var(--indent);
      }

      .display {
        /* pull display back to the far left */
        margin-left: calc(-1 * var(--indent));
      }

      /* name boxes = 90px on mobile */
      .name {
        width: 90px;
        flex: 0 0 90px;
      }

      /* prevent iOS zoom */
      input, button, textarea {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>

  <!-- Session / Sharing UI -->
  <div class="session-row">
    <input class="name" id="sessionCode" type="text" placeholder="">
    <input class="name" id="importBox" type="text" placeholder="">
    <input class="cb" id="importCb" type="checkbox">
    <input class="cb" id="exportCb" type="checkbox">
  </div>

  <div id="timers"></div>

  <script>
    const timersContainer = document.getElementById("timers");

    const STORAGE_KEY_BASE = "random_timers_v1_25";
    const TIMER_COUNT = 25;

    const MAX_HOURS = 99;
    const MAX_MINUTES = 59;
    const MAX_SECONDS = 59;
    const MAX_SOUNDS = 99;
    const MAX_DELAY = 99;

    // ---- Sound + Notification (GitHub Pages friendly) ----
    // IMPORTANT: Put "notification.wav" next to this HTML file (same exact lowercase name).
    const SOUND_URL = new URL("Notification.wav", document.baseURI).href;

    let audioUnlocked = false;
    let audioCtx = null;

    function unlockAudioOnce() {
      if (audioUnlocked) return;
      audioUnlocked = true;

      // Unlock WebAudio (helps iOS/Safari + autoplay rules)
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (Ctx) {
          audioCtx = new Ctx();
          audioCtx.resume().catch(() => {});
          const buf = audioCtx.createBuffer(1, 1, 22050);
          const src = audioCtx.createBufferSource();
          src.buffer = buf;
          src.connect(audioCtx.destination);
          src.start(0);
        }
      } catch {}

      // Preload sound (best effort)
      try {
        const a = new Audio(SOUND_URL);
        a.volume = 0.001;
        a.play().then(() => {
          a.pause();
          a.currentTime = 0;
        }).catch(() => {});
      } catch {}

      // Ask notification permission on first interaction (best effort)
      ensureNotificationPermission();
    }

    // Any user gesture will unlock audio + allow notifications
    document.addEventListener("pointerdown", unlockAudioOnce, { once: true });
    document.addEventListener("keydown", unlockAudioOnce, { once: true });

    function ensureNotificationPermission() {
      if (!("Notification" in window)) return;
      if (!window.isSecureContext) return; // Notifications require HTTPS or localhost
      if (Notification.permission === "default") {
        Notification.requestPermission().catch(() => {});
      }
    }

    function showBrowserNotification(title, body) {
      if (!("Notification" in window)) return;
      if (!window.isSecureContext) return;
      if (Notification.permission !== "granted") return;

      try {
        new Notification(title, { body });
      } catch {}
    }

    function playNotificationSoundOnce() {
      // If not unlocked yet, browsers may block play(); user gesture should unlock.
      try {
        const audio = new Audio(SOUND_URL);
        audio.volume = 0.75;
        audio.play().catch(() => {});
      } catch {}
    }

    function sanitizeSessionCode(s) {
      return (s || "").trim().replace(/[^a-zA-Z0-9_-]/g, "").slice(0, 40);
    }

    function getSessionKey() {
      const code = sanitizeSessionCode(localStorage.getItem(STORAGE_KEY_BASE + "_session") || "");
      return STORAGE_KEY_BASE + (code ? ("__" + code) : "");
    }

    // --------- Drag order persistence ---------
    function getOrderKey() {
      return getSessionKey() + "__order";
    }

    function loadOrder() {
      const raw = localStorage.getItem(getOrderKey());
      if (!raw) return null;

      try {
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return null;
        return arr.map(Number).filter((n) => Number.isFinite(n));
      } catch {
        return null;
      }
    }

    function saveOrder(orderIds) {
      localStorage.setItem(getOrderKey(), JSON.stringify(orderIds));
    }

    function applyOrder(itemsArr) {
      const order = loadOrder();
      if (!order || order.length === 0) return itemsArr;

      const byId = new Map();
      for (let i = 0; i < itemsArr.length; i++) byId.set(itemsArr[i].id, itemsArr[i]);

      const out = [];
      const used = new Set();

      for (let i = 0; i < order.length; i++) {
        const it = byId.get(order[i]);
        if (it && !used.has(it.id)) {
          out.push(it);
          used.add(it.id);
        }
      }

      for (let i = 0; i < itemsArr.length; i++) {
        const it = itemsArr[i];
        if (!used.has(it.id)) out.push(it);
      }

      return out;
    }

    function pad2(n) {
      return String(n).padStart(2, "0");
    }

    function formatHMSFixed(totalSeconds) {
      const t = Math.max(0, Math.floor(totalSeconds));
      const h = Math.floor(t / 3600);
      const m = Math.floor((t % 3600) / 60);
      const s = t % 60;
      const hh = (h < 100) ? pad2(h) : String(h);
      return hh + ":" + pad2(m) + ":" + pad2(s);
    }

    function blankIfZeroNumberInput(el, value) {
      if (value === 0) el.value = "";
      else el.value = value;
    }

    function readIntBlankZero(el, min, max) {
      const raw = el.value;
      const v = Number(raw === "" ? 0 : raw);
      let out = Math.floor(v);
      if (typeof min === "number") out = Math.max(min, out);
      if (typeof max === "number") out = Math.min(max, out);
      blankIfZeroNumberInput(el, out);
      return out;
    }

    function readFloatBlankZero(el, min, max) {
      const raw = el.value;
      const v = Number(raw === "" ? 0 : raw);

      let out = v;
      if (typeof min === "number") out = Math.max(min, out);
      if (typeof max === "number") out = Math.min(max, out);

      out = Math.floor(out * 100) / 100;

      blankIfZeroNumberInput(el, out);
      return out;
    }

    function setInitialBlankZeroInt(el, v, max) {
      const n = Math.max(0, Math.floor(Number(v || 0)));
      const out = (typeof max === "number") ? Math.min(max, n) : n;
      blankIfZeroNumberInput(el, out);
    }

    function setInitialBlankZeroFloat(el, v, max) {
      const n = Math.max(0, Number(v || 0));
      let out = (typeof max === "number") ? Math.min(max, n) : n;
      out = Math.floor(out * 100) / 100;
      blankIfZeroNumberInput(el, out);
    }

    function readHMS(hourEl, minEl, secEl) {
      const h = readIntBlankZero(hourEl, 0, MAX_HOURS);
      const m = readIntBlankZero(minEl, 0, MAX_MINUTES);
      const s = readIntBlankZero(secEl, 0, MAX_SECONDS);
      return h * 3600 + m * 60 + s;
    }

    function randomIntInclusive(a, b) {
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      return lo + Math.floor(Math.random() * (hi - lo + 1));
    }

    function readNotifySettings(countEl, delayEl) {
      const rawCount = countEl.value;
      const rawDelay = delayEl.value;

      let count = Math.floor(Number(rawCount === "" ? 1 : rawCount));
      let delay = Number(rawDelay === "" ? 0.25 : rawDelay);

      count = Math.max(0, Math.min(MAX_SOUNDS, count));
      delay = Math.max(0, Math.min(MAX_DELAY, delay));

      delay = Math.floor(delay * 100) / 100;

      if (rawCount !== "") blankIfZeroNumberInput(countEl, count);
      if (rawDelay !== "") blankIfZeroNumberInput(delayEl, delay);

      return { count, delay };
    }

    function setCheckboxChecked(cb, checked) {
      cb.checked = Boolean(checked);
    }

    function armOneShotCheckbox(cb, action) {
      cb.addEventListener("change", () => {
        if (!cb.checked) return;
        action();
        cb.checked = false;
      });
    }

    function blockNonNumericTyping(el, allowDot) {
      el.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey || e.altKey) return;

        const okKeys = [
          "Backspace", "Delete", "Tab", "Escape", "Enter",
          "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"
        ];
        if (okKeys.includes(e.key)) return;

        if (e.key >= "0" && e.key <= "9") return;
        if (allowDot && e.key === ".") return;

        if (e.key === "-") { e.preventDefault(); return; }

        e.preventDefault();
      });
    }

    function enforceTwoDecimals(el) {
      function fix() {
        let v = el.value;
        if (v === "") return;

        v = v.replace(/[^0-9.]/g, "");
        const firstDot = v.indexOf(".");
        if (firstDot !== -1) {
          const before = v.slice(0, firstDot + 1);
          const after = v.slice(firstDot + 1).replace(/\./g, "");
          v = before + after;
        }

        const dot = v.indexOf(".");
        if (dot !== -1) {
          const a = v.slice(0, dot);
          const b = v.slice(dot + 1, dot + 3);
          v = a + "." + b;
        }

        el.value = v;
      }

      el.addEventListener("input", fix);
      el.addEventListener("blur", fix);
    }

    // -------------------- DRAG & DROP (RAW) --------------------
    let draggingId = null;

    function enableDragDrop(row) {
      row.draggable = true;

      row.addEventListener("dragstart", (e) => {
        if (e.target && e.target.tagName === "INPUT") {
          e.preventDefault();
          return;
        }

        draggingId = Number(row.dataset.itemId);
        e.dataTransfer.effectAllowed = "move";
      });

      row.addEventListener("dragend", () => {
        draggingId = null;
      });

      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      row.addEventListener("drop", (e) => {
        e.preventDefault();
        if (draggingId === null) return;

        const targetId = Number(row.dataset.itemId);
        if (targetId === draggingId) return;

        const draggingRow = timersContainer.querySelector(`.timer-row[data-item-id="${draggingId}"]`);
        const targetRow = timersContainer.querySelector(`.timer-row[data-item-id="${targetId}"]`);
        if (!draggingRow || !targetRow) return;

        const rows = Array.from(timersContainer.querySelectorAll(".timer-row"));
        const dragIndex = rows.indexOf(draggingRow);
        const targetIndex = rows.indexOf(targetRow);

        if (dragIndex < targetIndex) timersContainer.insertBefore(draggingRow, targetRow.nextSibling);
        else timersContainer.insertBefore(draggingRow, targetRow);

        saveOrderFromDOM();
      });
    }

    function saveOrderFromDOM() {
      const rows = Array.from(timersContainer.querySelectorAll(".timer-row"));
      const newOrder = [];
      const orderIds = [];

      for (let i = 0; i < rows.length; i++) {
        const id = Number(rows[i].dataset.itemId);
        const item = getItemById(id);
        if (item) {
          newOrder.push(item);
          orderIds.push(id);
        }
      }

      items = newOrder;
      saveOrder(orderIds);
      saveState(items);
    }

    function loadState() {
      const raw = localStorage.getItem(getSessionKey());
      if (!raw) return null;

      try {
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveState(items) {
      localStorage.setItem(getSessionKey(), JSON.stringify(items));
    }

    function defaultItem(id) {
      return {
        id: id,
        type: "randomTimer",
        name: "",
        hA: 0, mA: 0, sA: 0,
        hB: 0, mB: 0, sB: 0,
        notifyCount: undefined,
        notifyDelay: undefined,
        totalSeconds: 0,
        mode: "idle",
        hasStarted: false,
        loopEnabled: false,
        notifyEnabled: false,
        intervalEnabled: false,
        intervalPhase: "A",
        runningBaseSeconds: 0,
        runningStartAt: 0
      };
    }

    function clampSavedItem(item) {
      const out = Object.assign(defaultItem(item.id), item);

      out.hA = Math.min(MAX_HOURS, Math.max(0, Number(out.hA || 0)));
      out.mA = Math.min(MAX_MINUTES, Math.max(0, Number(out.mA || 0)));
      out.sA = Math.min(MAX_SECONDS, Math.max(0, Number(out.sA || 0)));

      out.hB = Math.min(MAX_HOURS, Math.max(0, Number(out.hB || 0)));
      out.mB = Math.min(MAX_MINUTES, Math.max(0, Number(out.mB || 0)));
      out.sB = Math.min(MAX_SECONDS, Math.max(0, Number(out.sB || 0)));

      if (out.notifyCount !== undefined) out.notifyCount = Math.min(MAX_SOUNDS, Math.max(0, Number(out.notifyCount || 0)));
      if (out.notifyDelay !== undefined) out.notifyDelay = Math.min(MAX_DELAY, Math.max(0, Number(out.notifyDelay || 0)));

      if (out.notifyDelay !== undefined) out.notifyDelay = Math.floor(Number(out.notifyDelay) * 100) / 100;

      out.intervalEnabled = Boolean(out.intervalEnabled);
      out.intervalPhase = (out.intervalPhase === "B") ? "B" : "A";

      return out;
    }

    function ensureState() {
      const stored = loadState();

      if (!stored) {
        let fresh = [];
        for (let i = 0; i < TIMER_COUNT; i++) fresh.push(defaultItem(i + 1));
        fresh = applyOrder(fresh);
        saveState(fresh);
        return fresh;
      }

      const seen = new Set();
      let out = [];

      for (let i = 0; i < stored.length; i++) {
        const it = stored[i];
        if (!it || typeof it.id !== "number") continue;

        const id = Number(it.id);
        if (id < 1 || id > TIMER_COUNT) continue;
        if (seen.has(id)) continue;

        seen.add(id);
        out.push(clampSavedItem(it));
        if (out.length >= TIMER_COUNT) break;
      }

      for (let id = 1; id <= TIMER_COUNT; id++) {
        if (out.length >= TIMER_COUNT) break;
        if (!seen.has(id)) out.push(defaultItem(id));
      }

      out = applyOrder(out);
      saveState(out);
      return out;
    }

    let items = ensureState();

    function getItemById(id) {
      for (let i = 0; i < items.length; i++) {
        if (items[i].id === id) return items[i];
      }
      return null;
    }

    function upsertItem(item) {
      for (let i = 0; i < items.length; i++) {
        if (items[i].id === item.id) {
          items[i] = item;
          saveState(items);
          return;
        }
      }
    }

    // -------------------- TIMER ROWS --------------------
    function createRandomTimerRow(data) {
      const id = data.id;

      const row = document.createElement("div");
      row.className = "timer-row";
      row.dataset.itemId = String(id);

      row.innerHTML = `
        <div class="display" id="rDisplay${id}">00:00:00</div>
        <input class="name" id="rName${id}" type="text">
        <input class="num" id="rHourA${id}" type="number" min="0" max="${MAX_HOURS}">
        <input class="num" id="rMinA${id}" type="number" min="0" max="${MAX_MINUTES}">
        <input class="num" id="rSecA${id}" type="number" min="0" max="${MAX_SECONDS}">
        <input class="num" id="rHourB${id}" type="number" min="0" max="${MAX_HOURS}">
        <input class="num" id="rMinB${id}" type="number" min="0" max="${MAX_MINUTES}">
        <input class="num" id="rSecB${id}" type="number" min="0" max="${MAX_SECONDS}">
        <input class="num" id="rNCount${id}" type="number" min="0" max="${MAX_SOUNDS}">
        <input class="delay" id="rNDelay${id}" type="number" min="0" max="${MAX_DELAY}" step="0.01" inputmode="decimal">
        <input class="cb" id="rRun${id}" type="checkbox">
        <input class="cb" id="rReset${id}" type="checkbox">
        <input class="cb" id="rNotify${id}" type="checkbox">
        <input class="cb" id="rLoop${id}" type="checkbox">
        <input class="cb" id="rInterval${id}" type="checkbox">
        <input class="cb" id="rClear${id}" type="checkbox">
      `;

      timersContainer.appendChild(row);
      enableDragDrop(row);

      const display = document.getElementById(`rDisplay${id}`);
      const nameInput = document.getElementById(`rName${id}`);

      const hA = document.getElementById(`rHourA${id}`);
      const mA = document.getElementById(`rMinA${id}`);
      const sA = document.getElementById(`rSecA${id}`);

      const hB = document.getElementById(`rHourB${id}`);
      const mB = document.getElementById(`rMinB${id}`);
      const sB = document.getElementById(`rSecB${id}`);

      const nCountInput = document.getElementById(`rNCount${id}`);
      const nDelayInput = document.getElementById(`rNDelay${id}`);

      const runCb = document.getElementById(`rRun${id}`);
      const resetCb = document.getElementById(`rReset${id}`);
      const notifyCb = document.getElementById(`rNotify${id}`);
      const loopCb = document.getElementById(`rLoop${id}`);
      const intervalCb = document.getElementById(`rInterval${id}`);
      const clearCb = document.getElementById(`rClear${id}`);

      blockNonNumericTyping(hA, false);
      blockNonNumericTyping(mA, false);
      blockNonNumericTyping(sA, false);
      blockNonNumericTyping(hB, false);
      blockNonNumericTyping(mB, false);
      blockNonNumericTyping(sB, false);
      blockNonNumericTyping(nCountInput, false);
      blockNonNumericTyping(nDelayInput, true);
      enforceTwoDecimals(nDelayInput);

      let totalSeconds = Number(data.totalSeconds || 0);
      let intervalId = null;

      let hasStarted = Boolean(data.hasStarted);
      let intervalPhase = (data.intervalPhase === "B") ? "B" : "A";
      let runningBaseSeconds = Number(data.runningBaseSeconds || 0);
      let runningStartAt = Number(data.runningStartAt || 0);

      let soundTimeoutIds = [];
      let alive = true;

      function render() {
        display.textContent = formatHMSFixed(totalSeconds);
      }

      function clearAllSoundTimers() {
        for (let i = 0; i < soundTimeoutIds.length; i++) clearTimeout(soundTimeoutIds[i]);
        soundTimeoutIds = [];
      }

      function scheduleNotificationSounds() {
        clearAllSoundTimers();

        const ns = readNotifySettings(nCountInput, nDelayInput);
        if (ns.count <= 0) return;

        for (let i = 0; i < ns.count; i++) {
          const ms = Math.round(i * ns.delay * 1000);
          const t = setTimeout(() => {
            if (!alive) return;
            playNotificationSoundOnce();
          }, ms);
          soundTimeoutIds.push(t);
        }
      }

      function notifyBrowserFinished() {
        const timerName = (nameInput.value || "").trim();

        const title = timerName
          ? timerName
          : "Timer";

        showBrowserNotification(title, "");
      }

      function computeRunningSeconds() {
        const elapsed = Math.floor((Date.now() - runningStartAt) / 1000);
        return Math.max(0, runningBaseSeconds - elapsed);
      }

      function isABlank() {
        return hA.value === "" && mA.value === "" && sA.value === "";
      }

      function isBBlank() {
        return hB.value === "" && mB.value === "" && sB.value === "";
      }

      function getASeconds() {
        return readHMS(hA, mA, sA);
      }

      function getBSeconds() {
        return readHMS(hB, mB, sB);
      }

      function pickSecondsRandom() {
        const aBlank = isABlank();
        const bBlank = isBBlank();

        if (!aBlank && bBlank) return getASeconds();
        if (aBlank && !bBlank) return getBSeconds();
        if (!aBlank && !bBlank) {
          const a = getASeconds();
          const b = getBSeconds();
          return randomIntInclusive(a, b);
        }

        return 0;
      }

      function snapshot(mode) {
        const item = getItemById(id);
        if (!alive || !item) return;

        const ns = readNotifySettings(nCountInput, nDelayInput);

        item.name = nameInput.value || "";

        item.hA = readIntBlankZero(hA, 0, MAX_HOURS);
        item.mA = readIntBlankZero(mA, 0, MAX_MINUTES);
        item.sA = readIntBlankZero(sA, 0, MAX_SECONDS);

        item.hB = readIntBlankZero(hB, 0, MAX_HOURS);
        item.mB = readIntBlankZero(mB, 0, MAX_MINUTES);
        item.sB = readIntBlankZero(sB, 0, MAX_SECONDS);

        item.notifyCount = (nCountInput.value === "") ? undefined : ns.count;
        item.notifyDelay = (nDelayInput.value === "") ? undefined : ns.delay;

        item.loopEnabled = loopCb.checked;
        item.notifyEnabled = notifyCb.checked;
        item.intervalEnabled = intervalCb.checked;
        item.intervalPhase = intervalPhase;

        item.totalSeconds = totalSeconds;
        item.mode = mode;
        item.hasStarted = hasStarted;
        item.runningBaseSeconds = runningBaseSeconds;
        item.runningStartAt = runningStartAt;

        upsertItem(item);
      }

      function stopInterval() {
        if (intervalId !== null) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }

      function stopToIdle() {
        stopInterval();
        setCheckboxChecked(runCb, false);
        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;
        snapshot("idle");
      }

      function tick() {
        if (!alive) return;

        totalSeconds = computeRunningSeconds();
        render();
        snapshot("running");

        if (totalSeconds <= 0) {
          totalSeconds = 0;
          render();

          // Notify (sound + browser notification)
          if (notifyCb.checked) {
            ensureNotificationPermission();
            scheduleNotificationSounds();
            notifyBrowserFinished();
          }

          const aBlank = isABlank();
          const bBlank = isBBlank();
          const bothSet = !aBlank && !bBlank;

          if (intervalCb.checked && bothSet) {
            if (intervalPhase === "A") {
              intervalPhase = "B";
              const next = getBSeconds();
              if (next > 0) {
                runningBaseSeconds = next;
                runningStartAt = Date.now();
                totalSeconds = next;
                render();
                snapshot("running");
                return;
              }
            } else {
              if (loopCb.checked) {
                intervalPhase = "A";
                const next = getASeconds();
                if (next > 0) {
                  runningBaseSeconds = next;
                  runningStartAt = Date.now();
                  totalSeconds = next;
                  render();
                  snapshot("running");
                  return;
                }
              }
            }

            stopToIdle();
            return;
          }

          if (loopCb.checked) {
            const next = pickSecondsRandom();
            if (next > 0) {
              runningBaseSeconds = next;
              runningStartAt = Date.now();
              totalSeconds = next;
              render();
              snapshot("running");
              return;
            }
          }

          stopToIdle();
        }
      }

      function startRunning() {
        stopInterval();
        clearAllSoundTimers();

        // Best effort: unlock audio on run click
        unlockAudioOnce();

        if (!hasStarted) {
          const bothSet = !isABlank() && !isBBlank();

          let startSeconds = 0;

          if (intervalCb.checked && bothSet) {
            intervalPhase = "A";
            startSeconds = getASeconds();
          } else {
            startSeconds = pickSecondsRandom();
          }

          totalSeconds = startSeconds;

          if (totalSeconds <= 0) {
            setCheckboxChecked(runCb, false);
            return;
          }

          hasStarted = true;
        } else {
          if (totalSeconds <= 0) {
            setCheckboxChecked(runCb, false);
            return;
          }
        }

        runningBaseSeconds = totalSeconds;
        runningStartAt = Date.now();

        setCheckboxChecked(runCb, true);
        snapshot("running");

        intervalId = setInterval(tick, 250);
      }

      function pauseRunning() {
        totalSeconds = computeRunningSeconds();
        stopInterval();
        clearAllSoundTimers();

        setCheckboxChecked(runCb, false);

        runningBaseSeconds = totalSeconds;
        runningStartAt = 0;

        render();
        snapshot("paused");
      }

      function reset() {
        stopInterval();
        clearAllSoundTimers();

        totalSeconds = 0;
        render();

        setCheckboxChecked(runCb, false);
        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;

        snapshot("idle");
      }

      function clearTimer() {
        const ok = confirm();
        if (!ok) return;

        stopInterval();
        clearAllSoundTimers();

        nameInput.value = "";

        hA.value = "";
        mA.value = "";
        sA.value = "";

        hB.value = "";
        mB.value = "";
        sB.value = "";

        nCountInput.value = "";
        nDelayInput.value = "";

        setCheckboxChecked(runCb, false);
        setCheckboxChecked(notifyCb, false);
        setCheckboxChecked(loopCb, false);
        setCheckboxChecked(intervalCb, false);

        totalSeconds = 0;
        render();

        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;

        snapshot("idle");
      }

      function onInputsChangedIdle() {
        if (intervalId !== null) return;

        clearAllSoundTimers();
        totalSeconds = 0;
        render();

        setCheckboxChecked(runCb, false);
        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;

        snapshot("idle");
      }

      nameInput.value = data.name || "";

      setInitialBlankZeroInt(hA, data.hA, MAX_HOURS);
      setInitialBlankZeroInt(mA, data.mA, MAX_MINUTES);
      setInitialBlankZeroInt(sA, data.sA, MAX_SECONDS);

      setInitialBlankZeroInt(hB, data.hB, MAX_HOURS);
      setInitialBlankZeroInt(mB, data.mB, MAX_MINUTES);
      setInitialBlankZeroInt(sB, data.sB, MAX_SECONDS);

      const c = (data.notifyCount === undefined) ? 0 : Number(data.notifyCount || 0);
      const d = (data.notifyDelay === undefined) ? 0 : Number(data.notifyDelay || 0);
      setInitialBlankZeroInt(nCountInput, c, MAX_SOUNDS);
      setInitialBlankZeroFloat(nDelayInput, d, MAX_DELAY);

      setCheckboxChecked(loopCb, Boolean(data.loopEnabled));
      setCheckboxChecked(notifyCb, Boolean(data.notifyEnabled));
      setCheckboxChecked(intervalCb, Boolean(data.intervalEnabled));

      render();

      runCb.addEventListener("change", () => {
        if (runCb.checked) startRunning();
        else pauseRunning();
      });

      armOneShotCheckbox(resetCb, reset);
      armOneShotCheckbox(clearCb, clearTimer);

      loopCb.addEventListener("change", () => snapshot(intervalId !== null ? "running" : "idle"));

      notifyCb.addEventListener("change", () => {
        // Ask permission when user enables notifications
        if (notifyCb.checked) ensureNotificationPermission();
        snapshot(intervalId !== null ? "running" : "idle");
      });

      intervalCb.addEventListener("change", () => {
        intervalPhase = "A";
        snapshot(intervalId !== null ? "running" : "idle");
      });

      nameInput.addEventListener("input", () => snapshot(intervalId !== null ? "running" : "idle"));

      hA.addEventListener("input", onInputsChangedIdle);
      mA.addEventListener("input", onInputsChangedIdle);
      sA.addEventListener("input", onInputsChangedIdle);

      hB.addEventListener("input", onInputsChangedIdle);
      mB.addEventListener("input", onInputsChangedIdle);
      sB.addEventListener("input", onInputsChangedIdle);

      nCountInput.addEventListener("input", onInputsChangedIdle);
      nDelayInput.addEventListener("input", onInputsChangedIdle);

      hA.addEventListener("blur", () => readIntBlankZero(hA, 0, MAX_HOURS));
      mA.addEventListener("blur", () => readIntBlankZero(mA, 0, MAX_MINUTES));
      sA.addEventListener("blur", () => readIntBlankZero(sA, 0, MAX_SECONDS));

      hB.addEventListener("blur", () => readIntBlankZero(hB, 0, MAX_HOURS));
      mB.addEventListener("blur", () => readIntBlankZero(mB, 0, MAX_MINUTES));
      sB.addEventListener("blur", () => readIntBlankZero(sB, 0, MAX_SECONDS));

      nCountInput.addEventListener("blur", () => readIntBlankZero(nCountInput, 0, MAX_SOUNDS));
      nDelayInput.addEventListener("blur", () => readFloatBlankZero(nDelayInput, 0, MAX_DELAY));

      if (data.mode === "running" && typeof data.runningStartAt === "number" && typeof data.runningBaseSeconds === "number") {
        runningBaseSeconds = Number(data.runningBaseSeconds || 0);
        runningStartAt = Number(data.runningStartAt || Date.now());

        totalSeconds = computeRunningSeconds();
        render();

        setCheckboxChecked(runCb, true);
        intervalId = setInterval(tick, 250);
      } else {
        setCheckboxChecked(runCb, false);
      }

      snapshot(data.mode || "idle");

      row._cleanup = () => {
        alive = false;
        stopInterval();
        clearAllSoundTimers();
      };
    }

    function teardownAllRows() {
      const rows = Array.from(timersContainer.querySelectorAll(".timer-row"));
      for (let i = 0; i < rows.length; i++) {
        if (rows[i]._cleanup) rows[i]._cleanup();
      }
      timersContainer.innerHTML = "";
    }

    function renderAllTimers() {
      teardownAllRows();
      items = ensureState();
      for (let i = 0; i < items.length; i++) {
        createRandomTimerRow(items[i]);
      }
    }

    // -------- Session + Import wiring (checkbox-style like Clear) --------
    const sessionInput = document.getElementById("sessionCode");
    const importBox = document.getElementById("importBox");
    const importCb = document.getElementById("importCb");
    const exportCb = document.getElementById("exportCb");

    sessionInput.value = sanitizeSessionCode(localStorage.getItem(STORAGE_KEY_BASE + "_session") || "");

    sessionInput.addEventListener("input", () => {
      const clean = sanitizeSessionCode(sessionInput.value);
      sessionInput.value = clean;
      localStorage.setItem(STORAGE_KEY_BASE + "_session", clean);
      renderAllTimers();
    });

    armOneShotCheckbox(exportCb, async () => {
      const data = localStorage.getItem(getSessionKey()) || "[]";
      await navigator.clipboard.writeText(data);
      alert();
    });

    armOneShotCheckbox(importCb, () => {
      const text = importBox.value.trim();
      if (!text) return;

      try {
        const parsed = JSON.parse(text);
        if (!Array.isArray(parsed)) throw new Error("Not an array");
        localStorage.setItem(getSessionKey(), JSON.stringify(parsed));

        // also store order if present
        const ids = [];
        for (let i = 0; i < parsed.length; i++) ids.push(Number(parsed[i].id));
        saveOrder(ids);

        importBox.value = "";
        renderAllTimers();
        alert();
      } catch {
        alert("Invalid JSON. Paste only the array that starts with [ and ends with ].");
      }
    });

    // -------- Initial render --------
    renderAllTimers();
  </script>

</body>
</html>