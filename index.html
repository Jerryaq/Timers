<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Timers</title>

  <style>
    :root {
      --displayw: 80px;
      --gap: 5px;
      --indent: calc(var(--displayw) + (2 * var(--gap)));
    }

    body {
      font-family: Arial, sans-serif;
      font-size: 15px;
      margin: 5px;
    }

    input, button, textarea {
      font-family: Arial, sans-serif;
      font-size: 15px;
    }

    /* Remove number input spinners */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    #timers {
      overflow-x: visible;
    }

    .timer-row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      margin-bottom: 5px;
      user-select: none;
      flex-wrap: nowrap; /* desktop unchanged */
    }

    .display {
      font-size: 20px;
      margin-right: var(--gap);
      min-width: var(--displayw);
      text-align: right;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      cursor: grab; /* drag handle */
    }

    .display:active {
      cursor: grabbing;
    }

    .name {
      width: 100px;
      box-sizing: border-box;
    }

    /* small boxes: 25x25 */
    .num {
      width: 25px;
      height: 25px;
      box-sizing: border-box;
      padding: 0;
      text-align: left;
    }

    /* time boxes: 66px wide */
    .timebox {
      width: 66px;
      height: 25px;
      box-sizing: border-box;
      padding: 0 2px;
      text-align: left;
    }

    .cb {
      width: 25px;
      height: 25px;
      margin: 0;
    }

    /* Counter is display-only (not editable/clickable) */
    .counter {
      pointer-events: none;
    }

    /* Session + Import UI */
    .session-row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      margin-bottom: 10px;
      user-select: none;
      flex-wrap: nowrap;
    }

    /* ---------------- MOBILE ---------------- */
    @media (max-width: 700px) {

      .timer-row {
        flex-wrap: wrap;

        /* indent wrapped rows so they align with name */
        padding-left: var(--indent);
      }

      .display {
        /* pull display back to the far left */
        margin-left: calc(-1 * var(--indent));
      }

      /* name boxes = 95px on mobile */
      .name {
        width: 95px;
        flex: 0 0 95px;
      }

      /* prevent iOS zoom */
      input, button, textarea {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>

  <!-- Session / Sharing UI -->
  <div class="session-row">
    <input class="name" id="sessionCode" type="text" placeholder="">
    <input class="name" id="importBox" type="text" placeholder="">
    <input class="cb" id="importCb" type="checkbox">
    <input class="cb" id="exportCb" type="checkbox">
  </div>

  <div id="timers"></div>

  <script>
    const timersContainer = document.getElementById("timers");

    const STORAGE_KEY_BASE = "random_timers_v1_25";
    const TIMER_COUNT = 25;

    const MAX_HOURS = 99;
    const MAX_MINUTES = 59;
    const MAX_SECONDS = 59;

    const MAX_COUNTER = 99;

    // Fixed: play 2 sounds, 0.25s apart
    const FIXED_NOTIFY_COUNT = 2;
    const FIXED_NOTIFY_DELAY_SECONDS = 0.25;

    function pad2str(n) {
      return String(n).padStart(2, "0");
    }

    function todayStampLocal() {
      const d = new Date();
      return String(d.getFullYear()) + "-" + pad2str(d.getMonth() + 1) + "-" + pad2str(d.getDate());
    }

    // ---- Sound + Notification (GitHub Pages friendly) ----
    // IMPORTANT: Put "Notification.wav" next to this HTML file (same exact lowercase name).
    const SOUND_URL = new URL("Notification.wav", document.baseURI).href;

    let audioUnlocked = false;
    let audioCtx = null;

    function unlockAudioOnce() {
      if (audioUnlocked) return;
      audioUnlocked = true;

      // Unlock WebAudio (helps iOS/Safari + autoplay rules)
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (Ctx) {
          audioCtx = new Ctx();
          audioCtx.resume().catch(() => {});
          const buf = audioCtx.createBuffer(1, 1, 22050);
          const src = audioCtx.createBufferSource();
          src.buffer = buf;
          src.connect(audioCtx.destination);
          src.start(0);
        }
      } catch {}

      // Preload sound (best effort)
      try {
        const a = new Audio(SOUND_URL);
        a.preload = "auto";
        a.volume = 0.001;
        a.play().then(() => {
          a.pause();
          a.currentTime = 0;
        }).catch(() => {});
      } catch {}

      // Ask notification permission on first interaction (best effort)
      ensureNotificationPermission();
    }

    // Any user gesture will unlock audio + allow notifications
    document.addEventListener("pointerdown", unlockAudioOnce, { once: true });
    document.addEventListener("keydown", unlockAudioOnce, { once: true });

    function ensureNotificationPermission() {
      if (!("Notification" in window)) return;
      if (!window.isSecureContext) return; // Notifications require HTTPS or localhost
      if (Notification.permission === "default") {
        Notification.requestPermission().catch(() => {});
      }
    }

    function showBrowserNotification(title, body) {
      if (!("Notification" in window)) return;
      if (!window.isSecureContext) return;
      if (Notification.permission !== "granted") return;

      try {
        new Notification(title, { body });
      } catch {}
    }

    function playNotificationSoundOnce() {
      try {
        const audio = new Audio(SOUND_URL);
        audio.preload = "auto";
        audio.volume = 0.75;
        audio.play().catch(() => {});
      } catch {}
    }

    function sanitizeSessionCode(s) {
      return (s || "").trim().replace(/[^a-zA-Z0-9_-]/g, "").slice(0, 40);
    }

    function getSessionKey() {
      const code = sanitizeSessionCode(localStorage.getItem(STORAGE_KEY_BASE + "_session") || "");
      return STORAGE_KEY_BASE + (code ? ("__" + code) : "");
    }

    // --------- Daily counter reset (12:00 AM local) ---------
    function getCounterResetKey() {
      return getSessionKey() + "__counter_reset_day";
    }

    function resetAllCountersNow() {
      for (let i = 0; i < items.length; i++) {
        items[i].counter = 0;
      }
      saveState(items);

      const counterEls = Array.from(timersContainer.querySelectorAll("input.counter"));
      for (let i = 0; i < counterEls.length; i++) {
        counterEls[i].value = "";
      }
    }

    function maybeResetCountersForNewDay() {
      const key = getCounterResetKey();
      const today = todayStampLocal();
      const last = localStorage.getItem(key) || "";

      if (last !== today) {
        resetAllCountersNow();
        localStorage.setItem(key, today);
      }
    }

    function msUntilNextLocalMidnight() {
      const now = new Date();
      const next = new Date(now);
      next.setHours(24, 0, 0, 0);
      return Math.max(1000, next.getTime() - now.getTime());
    }

    function scheduleMidnightCounterReset() {
      setTimeout(() => {
        maybeResetCountersForNewDay();
        scheduleMidnightCounterReset();
      }, msUntilNextLocalMidnight());
    }

    // --------- Drag order persistence ---------
    function getOrderKey() {
      return getSessionKey() + "__order";
    }

    function loadOrder() {
      const raw = localStorage.getItem(getOrderKey());
      if (!raw) return null;

      try {
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return null;
        return arr.map(Number).filter((n) => Number.isFinite(n));
      } catch {
        return null;
      }
    }

    function saveOrder(orderIds) {
      localStorage.setItem(getOrderKey(), JSON.stringify(orderIds));
    }

    function applyOrder(itemsArr) {
      const order = loadOrder();
      if (!order || order.length === 0) return itemsArr;

      const byId = new Map();
      for (let i = 0; i < itemsArr.length; i++) byId.set(itemsArr[i].id, itemsArr[i]);

      const out = [];
      const used = new Set();

      for (let i = 0; i < order.length; i++) {
        const it = byId.get(order[i]);
        if (it && !used.has(it.id)) {
          out.push(it);
          used.add(it.id);
        }
      }

      for (let i = 0; i < itemsArr.length; i++) {
        const it = itemsArr[i];
        if (!used.has(it.id)) out.push(it);
      }

      return out;
    }

    function pad2(n) {
      return String(n).padStart(2, "0");
    }

    function formatHMSFixed(totalSeconds) {
      const t = Math.max(0, Math.floor(totalSeconds));
      const h = Math.floor(t / 3600);
      const m = Math.floor((t % 3600) / 60);
      const s = t % 60;
      const hh = (h < 100) ? pad2(h) : String(h);
      return hh + ":" + pad2(m) + ":" + pad2(s);
    }

    function blankIfZeroNumberInput(el, value) {
      if (value === 0) el.value = "";
      else el.value = value;
    }

    function readIntBlankZero(el, min, max) {
      const raw = el.value;
      const v = Number(raw === "" ? 0 : raw);
      let out = Math.floor(v);
      if (typeof min === "number") out = Math.max(min, out);
      if (typeof max === "number") out = Math.min(max, out);
      blankIfZeroNumberInput(el, out);
      return out;
    }

    function setInitialBlankZeroInt(el, v, max) {
      const n = Math.max(0, Math.floor(Number(v || 0)));
      const out = (typeof max === "number") ? Math.min(max, n) : n;
      blankIfZeroNumberInput(el, out);
    }

    // --------- Time input parsing: "1:23:42" (also allows "23:42" or "42") ---------
    function parseTimeToSeconds(raw) {
      const s = String(raw || "").trim();
      if (s === "") return { blank: true, seconds: 0 };

      const parts = s.split(":").map((p) => p.trim()).filter((p) => p !== "");
      if (parts.length === 0 || parts.length > 3) return { blank: false, seconds: 0, invalid: true };

      for (let i = 0; i < parts.length; i++) {
        if (!/^\d+$/.test(parts[i])) return { blank: false, seconds: 0, invalid: true };
      }

      let h = 0, m = 0, sec = 0;

      if (parts.length === 3) {
        h = Number(parts[0]);
        m = Number(parts[1]);
        sec = Number(parts[2]);
      } else if (parts.length === 2) {
        m = Number(parts[0]);
        sec = Number(parts[1]);
      } else {
        sec = Number(parts[0]);
      }

      h = Math.min(MAX_HOURS, Math.max(0, Math.floor(h)));
      m = Math.min(MAX_MINUTES, Math.max(0, Math.floor(m)));
      sec = Math.min(MAX_SECONDS, Math.max(0, Math.floor(sec)));

      return { blank: false, seconds: h * 3600 + m * 60 + sec };
    }

    function formatTimeForBox(totalSeconds) {
      const t = Math.max(0, Math.floor(totalSeconds));
      const h = Math.floor(t / 3600);
      const m = Math.floor((t % 3600) / 60);
      const s = t % 60;

      // minimum 2 digits, but don't force 3
      const hh = (h < 10) ? "0" + h : String(h);

      return hh + ":" + pad2(m) + ":" + pad2(s);
    }

    function normalizeTimeBox(el) {
      const parsed = parseTimeToSeconds(el.value);
      if (parsed.blank) {
        el.value = "";
        return 0;
      }
      if (parsed.invalid) {
        el.value = "";
        return 0;
      }
      el.value = formatTimeForBox(parsed.seconds);
      return parsed.seconds;
    }

    function blockTimeTyping(el) {
      el.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey || e.altKey) return;

        const okKeys = [
          "Backspace", "Delete", "Tab", "Escape", "Enter",
          "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"
        ];
        if (okKeys.includes(e.key)) return;

        if (e.key >= "0" && e.key <= "9") return;
        if (e.key === ":") return;

        e.preventDefault();
      });
    }

    function randomIntInclusive(a, b) {
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      return lo + Math.floor(Math.random() * (hi - lo + 1));
    }

    function getNotifySettingsFixed() {
      return { count: FIXED_NOTIFY_COUNT, delay: FIXED_NOTIFY_DELAY_SECONDS };
    }

    function setCheckboxChecked(cb, checked) {
      cb.checked = Boolean(checked);
    }

    function armOneShotCheckbox(cb, action) {
      cb.addEventListener("change", () => {
        if (!cb.checked) return;
        action();
        cb.checked = false;
      });
    }

    // -------------------- DRAG & DROP (HANDLE-ONLY) --------------------
    let draggingId = null;

    function enableDragDrop(row, handleEl) {
      handleEl.draggable = true;

      handleEl.addEventListener("dragstart", (e) => {
        draggingId = Number(row.dataset.itemId);
        e.dataTransfer.effectAllowed = "move";
      });

      handleEl.addEventListener("dragend", () => {
        draggingId = null;
      });

      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      row.addEventListener("drop", (e) => {
        e.preventDefault();
        if (draggingId === null) return;

        const targetId = Number(row.dataset.itemId);
        if (targetId === draggingId) return;

        const draggingRow = timersContainer.querySelector(`.timer-row[data-item-id="${draggingId}"]`);
        const targetRow = timersContainer.querySelector(`.timer-row[data-item-id="${targetId}"]`);
        if (!draggingRow || !targetRow) return;

        const rows = Array.from(timersContainer.querySelectorAll(".timer-row"));
        const dragIndex = rows.indexOf(draggingRow);
        const targetIndex = rows.indexOf(targetRow);

        if (dragIndex < targetIndex) timersContainer.insertBefore(draggingRow, targetRow.nextSibling);
        else timersContainer.insertBefore(draggingRow, targetRow);

        saveOrderFromDOM();
      });
    }

    function saveOrderFromDOM() {
      const rows = Array.from(timersContainer.querySelectorAll(".timer-row"));
      const newOrder = [];
      const orderIds = [];

      for (let i = 0; i < rows.length; i++) {
        const id = Number(rows[i].dataset.itemId);
        const item = getItemById(id);
        if (item) {
          newOrder.push(item);
          orderIds.push(id);
        }
      }

      items = newOrder;
      saveOrder(orderIds);
      saveState(items);
    }

    function loadState() {
      const raw = localStorage.getItem(getSessionKey());
      if (!raw) return null;

      try {
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveState(items) {
      localStorage.setItem(getSessionKey(), JSON.stringify(items));
    }

    function defaultItem(id) {
      return {
        id: id,
        type: "randomTimer",
        name: "",
        aStr: "",
        bStr: "",
        counter: 0,
        totalSeconds: 0,
        mode: "idle",
        hasStarted: false,
        loopEnabled: false,
        notifyEnabled: false,
        intervalEnabled: false,
        intervalPhase: "A",
        runningBaseSeconds: 0,
        runningStartAt: 0
      };
    }

    function clampSavedItem(item) {
      const out = Object.assign(defaultItem(item.id), item);

      // Back-compat: if old hA/mA/sA exist, convert to aStr/bStr once
      const hasOldA = (out.hA !== undefined || out.mA !== undefined || out.sA !== undefined);
      const hasOldB = (out.hB !== undefined || out.mB !== undefined || out.sB !== undefined);

      if (!out.aStr && hasOldA) {
        const h = Math.min(MAX_HOURS, Math.max(0, Number(out.hA || 0)));
        const m = Math.min(MAX_MINUTES, Math.max(0, Number(out.mA || 0)));
        const s = Math.min(MAX_SECONDS, Math.max(0, Number(out.sA || 0)));
        if (h !== 0 || m !== 0 || s !== 0) out.aStr = String(h) + ":" + pad2(m) + ":" + pad2(s);
      }

      if (!out.bStr && hasOldB) {
        const h = Math.min(MAX_HOURS, Math.max(0, Number(out.hB || 0)));
        const m = Math.min(MAX_MINUTES, Math.max(0, Number(out.mB || 0)));
        const s = Math.min(MAX_SECONDS, Math.max(0, Number(out.sB || 0)));
        if (h !== 0 || m !== 0 || s !== 0) out.bStr = String(h) + ":" + pad2(m) + ":" + pad2(s);
      }

      out.aStr = String(out.aStr || "");
      out.bStr = String(out.bStr || "");

      out.counter = Math.min(MAX_COUNTER, Math.max(0, Number(out.counter || 0)));

      out.intervalEnabled = Boolean(out.intervalEnabled);
      out.intervalPhase = (out.intervalPhase === "B") ? "B" : "A";

      return out;
    }

    function ensureState() {
      const stored = loadState();

      if (!stored) {
        let fresh = [];
        for (let i = 0; i < TIMER_COUNT; i++) fresh.push(defaultItem(i + 1));
        fresh = applyOrder(fresh);
        saveState(fresh);
        return fresh;
      }

      const seen = new Set();
      let out = [];

      for (let i = 0; i < stored.length; i++) {
        const it = stored[i];
        if (!it || typeof it.id !== "number") continue;

        const id = Number(it.id);
        if (id < 1 || id > TIMER_COUNT) continue;
        if (seen.has(id)) continue;

        seen.add(id);
        out.push(clampSavedItem(it));
        if (out.length >= TIMER_COUNT) break;
      }

      for (let id = 1; id <= TIMER_COUNT; id++) {
        if (out.length >= TIMER_COUNT) break;
        if (!seen.has(id)) out.push(defaultItem(id));
      }

      out = applyOrder(out);
      saveState(out);
      return out;
    }

    let items = ensureState();

    function getItemById(id) {
      for (let i = 0; i < items.length; i++) {
        if (items[i].id === id) return items[i];
      }
      return null;
    }

    function upsertItem(item) {
      for (let i = 0; i < items.length; i++) {
        if (items[i].id === item.id) {
          items[i] = item;
          saveState(items);
          return;
        }
      }
    }

    // -------------------- TIMER ROWS --------------------
    function createRandomTimerRow(data) {
      const id = data.id;

      const row = document.createElement("div");
      row.className = "timer-row";
      row.dataset.itemId = String(id);

      row.innerHTML = `
        <div class="display" id="rDisplay${id}">00:00:00</div>
        <input class="name" id="rName${id}" type="text">

        <input class="timebox" id="rTimeA${id}" type="text" inputmode="numeric" placeholder="">
        <input class="timebox" id="rTimeB${id}" type="text" inputmode="numeric" placeholder="">

        <input class="num counter" id="rCounter${id}" type="number" min="0" max="${MAX_COUNTER}" readonly tabindex="-1">
        <input class="cb" id="rCounterDec${id}" type="checkbox">

        <!-- reset then start -->
        <input class="cb" id="rReset${id}" type="checkbox">
        <input class="cb" id="rRun${id}" type="checkbox">

        <input class="cb" id="rNotify${id}" type="checkbox">
        <input class="cb" id="rLoop${id}" type="checkbox">
        <input class="cb" id="rInterval${id}" type="checkbox">
      `;

      timersContainer.appendChild(row);

      const display = document.getElementById(`rDisplay${id}`);
      enableDragDrop(row, display);

      const nameInput = document.getElementById(`rName${id}`);

      const timeA = document.getElementById(`rTimeA${id}`);
      const timeB = document.getElementById(`rTimeB${id}`);

      const counterInput = document.getElementById(`rCounter${id}`);
      const counterDecCb = document.getElementById(`rCounterDec${id}`);

      const resetCb = document.getElementById(`rReset${id}`);
      const runCb = document.getElementById(`rRun${id}`);

      const notifyCb = document.getElementById(`rNotify${id}`);
      const loopCb = document.getElementById(`rLoop${id}`);
      const intervalCb = document.getElementById(`rInterval${id}`);

      blockTimeTyping(timeA);
      blockTimeTyping(timeB);

      // extra safety: counter cannot be changed even if focused somehow
      counterInput.addEventListener("keydown", (e) => e.preventDefault());
      counterInput.addEventListener("paste", (e) => e.preventDefault());
      counterInput.addEventListener("wheel", (e) => e.preventDefault(), { passive: false });

      let totalSeconds = Number(data.totalSeconds || 0);
      let intervalId = null;

      let hasStarted = Boolean(data.hasStarted);
      let intervalPhase = (data.intervalPhase === "B") ? "B" : "A";
      let runningBaseSeconds = Number(data.runningBaseSeconds || 0);
      let runningStartAt = Number(data.runningStartAt || 0);

      let soundTimeoutIds = [];
      let alive = true;

      function render() {
        display.textContent = formatHMSFixed(totalSeconds);
      }

      function clearAllSoundTimers() {
        for (let i = 0; i < soundTimeoutIds.length; i++) clearTimeout(soundTimeoutIds[i]);
        soundTimeoutIds = [];
      }

      function scheduleNotificationSounds() {
        clearAllSoundTimers();

        const ns = getNotifySettingsFixed();
        for (let i = 0; i < ns.count; i++) {
          const ms = Math.round(i * ns.delay * 1000);
          const t = setTimeout(() => {
            if (!alive) return;
            playNotificationSoundOnce();
          }, ms);
          soundTimeoutIds.push(t);
        }
      }

      function notifyBrowserFinished() {
        const timerName = (nameInput.value || "").trim();
        const title = timerName ? timerName : "Timer";
        showBrowserNotification(title, "");
      }

      function computeRunningSeconds() {
        const elapsed = Math.floor((Date.now() - runningStartAt) / 1000);
        return Math.max(0, runningBaseSeconds - elapsed);
      }

      function isABlank() {
        return String(timeA.value || "").trim() === "";
      }

      function isBBlank() {
        return String(timeB.value || "").trim() === "";
      }

      function getASeconds() {
        const p = parseTimeToSeconds(timeA.value);
        if (p.blank || p.invalid) return 0;
        return p.seconds;
      }

      function getBSeconds() {
        const p = parseTimeToSeconds(timeB.value);
        if (p.blank || p.invalid) return 0;
        return p.seconds;
      }

      function pickSecondsRandom() {
        const aBlank = isABlank();
        const bBlank = isBBlank();

        if (!aBlank && bBlank) return getASeconds();
        if (aBlank && !bBlank) return getBSeconds();
        if (!aBlank && !bBlank) {
          const a = getASeconds();
          const b = getBSeconds();
          return randomIntInclusive(a, b);
        }

        return 0;
      }

      function incCounterBy1() {
        const cur = Number(counterInput.value === "" ? 0 : counterInput.value);
        const next = Math.min(MAX_COUNTER, Math.max(0, cur + 1));
        blankIfZeroNumberInput(counterInput, next);
      }

      function decCounterBy1() {
        const cur = Number(counterInput.value === "" ? 0 : counterInput.value);
        const next = Math.min(MAX_COUNTER, Math.max(0, cur - 1));
        blankIfZeroNumberInput(counterInput, next);
      }

      function snapshot(mode) {
        const item = getItemById(id);
        if (!alive || !item) return;

        item.name = nameInput.value || "";

        item.aStr = String(timeA.value || "");
        item.bStr = String(timeB.value || "");

        item.loopEnabled = loopCb.checked;
        item.notifyEnabled = notifyCb.checked;
        item.intervalEnabled = intervalCb.checked;
        item.intervalPhase = intervalPhase;

        item.counter = Math.min(MAX_COUNTER, Math.max(0, Number(counterInput.value === "" ? 0 : counterInput.value)));

        item.totalSeconds = totalSeconds;
        item.mode = mode;
        item.hasStarted = hasStarted;
        item.runningBaseSeconds = runningBaseSeconds;
        item.runningStartAt = runningStartAt;

        upsertItem(item);
      }

      function stopInterval() {
        if (intervalId !== null) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }

      function stopToIdle() {
        stopInterval();
        setCheckboxChecked(runCb, false);
        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;
        snapshot("idle");
      }

      function tick() {
        if (!alive) return;

        totalSeconds = computeRunningSeconds();
        render();
        snapshot("running");

        if (totalSeconds <= 0) {
          totalSeconds = 0;
          render();

          incCounterBy1();
          snapshot("running");

          if (notifyCb.checked) {
            ensureNotificationPermission();
            scheduleNotificationSounds();
            notifyBrowserFinished();
          }

          const aBlank = isABlank();
          const bBlank = isBBlank();
          const bothSet = !aBlank && !bBlank;

          if (intervalCb.checked && bothSet) {
            if (intervalPhase === "A") {
              intervalPhase = "B";
              const next = getBSeconds();
              if (next > 0) {
                runningBaseSeconds = next;
                runningStartAt = Date.now();
                totalSeconds = next;
                render();
                snapshot("running");
                return;
              }
            } else {
              if (loopCb.checked) {
                intervalPhase = "A";
                const next = getASeconds();
                if (next > 0) {
                  runningBaseSeconds = next;
                  runningStartAt = Date.now();
                  totalSeconds = next;
                  render();
                  snapshot("running");
                  return;
                }
              }
            }

            stopToIdle();
            return;
          }

          if (loopCb.checked) {
            const next = pickSecondsRandom();
            if (next > 0) {
              runningBaseSeconds = next;
              runningStartAt = Date.now();
              totalSeconds = next;
              render();
              snapshot("running");
              return;
            }
          }

          stopToIdle();
        }
      }

      function startRunning() {
        stopInterval();
        clearAllSoundTimers();

        unlockAudioOnce();

        if (!hasStarted) {
          const bothSet = !isABlank() && !isBBlank();

          let startSeconds = 0;

          if (intervalCb.checked && bothSet) {
            intervalPhase = "A";
            startSeconds = getASeconds();
          } else {
            startSeconds = pickSecondsRandom();
          }

          totalSeconds = startSeconds;

          if (totalSeconds <= 0) {
            setCheckboxChecked(runCb, false);
            return;
          }

          hasStarted = true;
        } else {
          if (totalSeconds <= 0) {
            setCheckboxChecked(runCb, false);
            return;
          }
        }

        runningBaseSeconds = totalSeconds;
        runningStartAt = Date.now();

        setCheckboxChecked(runCb, true);
        snapshot("running");

        intervalId = setInterval(tick, 250);
      }

      function pauseRunning() {
        totalSeconds = computeRunningSeconds();
        stopInterval();
        clearAllSoundTimers();

        setCheckboxChecked(runCb, false);

        runningBaseSeconds = totalSeconds;
        runningStartAt = 0;

        render();
        snapshot("paused");
      }

      function reset() {
        stopInterval();
        clearAllSoundTimers();

        totalSeconds = 0;
        render();

        setCheckboxChecked(runCb, false);
        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;

        snapshot("idle");
      }

      function onInputsChangedIdle() {
        if (intervalId !== null) return;

        clearAllSoundTimers();
        totalSeconds = 0;
        render();

        setCheckboxChecked(runCb, false);
        hasStarted = false;
        intervalPhase = "A";
        runningBaseSeconds = 0;
        runningStartAt = 0;

        snapshot("idle");
      }

      nameInput.value = data.name || "";

      timeA.value = String(data.aStr || "");
      timeB.value = String(data.bStr || "");

      // normalize on load (keeps blanks blank)
      if (String(timeA.value || "").trim() !== "") normalizeTimeBox(timeA);
      if (String(timeB.value || "").trim() !== "") normalizeTimeBox(timeB);

      setInitialBlankZeroInt(counterInput, data.counter, MAX_COUNTER);

      setCheckboxChecked(loopCb, Boolean(data.loopEnabled));
      setCheckboxChecked(notifyCb, Boolean(data.notifyEnabled));
      setCheckboxChecked(intervalCb, Boolean(data.intervalEnabled));

      render();

      runCb.addEventListener("change", () => {
        if (runCb.checked) startRunning();
        else pauseRunning();
      });

      armOneShotCheckbox(resetCb, reset);

      armOneShotCheckbox(counterDecCb, () => {
        decCounterBy1();
        snapshot(intervalId !== null ? "running" : "idle");
      });

      loopCb.addEventListener("change", () => snapshot(intervalId !== null ? "running" : "idle"));

      notifyCb.addEventListener("change", () => {
        if (notifyCb.checked) ensureNotificationPermission();
        snapshot(intervalId !== null ? "running" : "idle");
      });

      intervalCb.addEventListener("change", () => {
        intervalPhase = "A";
        snapshot(intervalId !== null ? "running" : "idle");
      });

      nameInput.addEventListener("input", () => snapshot(intervalId !== null ? "running" : "idle"));

      timeA.addEventListener("input", onInputsChangedIdle);
      timeB.addEventListener("input", onInputsChangedIdle);

      timeA.addEventListener("blur", () => { normalizeTimeBox(timeA); snapshot(intervalId !== null ? "running" : "idle"); });
      timeB.addEventListener("blur", () => { normalizeTimeBox(timeB); snapshot(intervalId !== null ? "running" : "idle"); });

      if (data.mode === "running" && typeof data.runningStartAt === "number" && typeof data.runningBaseSeconds === "number") {
        runningBaseSeconds = Number(data.runningBaseSeconds || 0);
        runningStartAt = Number(data.runningStartAt || Date.now());

        totalSeconds = computeRunningSeconds();
        render();

        setCheckboxChecked(runCb, true);
        intervalId = setInterval(tick, 250);
      } else {
        setCheckboxChecked(runCb, false);
      }

      snapshot(data.mode || "idle");

      row._cleanup = () => {
        alive = false;
        stopInterval();
        clearAllSoundTimers();
      };
    }

    function teardownAllRows() {
      const rows = Array.from(timersContainer.querySelectorAll(".timer-row"));
      for (let i = 0; i < rows.length; i++) {
        if (rows[i]._cleanup) rows[i]._cleanup();
      }
      timersContainer.innerHTML = "";
    }

    function renderAllTimers() {
      teardownAllRows();
      items = ensureState();

      maybeResetCountersForNewDay();

      for (let i = 0; i < items.length; i++) {
        createRandomTimerRow(items[i]);
      }
    }

    // -------- Session + Import wiring --------
    const sessionInput = document.getElementById("sessionCode");
    const importBox = document.getElementById("importBox");
    const importCb = document.getElementById("importCb");
    const exportCb = document.getElementById("exportCb");

    sessionInput.value = sanitizeSessionCode(localStorage.getItem(STORAGE_KEY_BASE + "_session") || "");

    sessionInput.addEventListener("input", () => {
      const clean = sanitizeSessionCode(sessionInput.value);
      sessionInput.value = clean;
      localStorage.setItem(STORAGE_KEY_BASE + "_session", clean);
      renderAllTimers();
    });

    armOneShotCheckbox(exportCb, async () => {
      const data = localStorage.getItem(getSessionKey()) || "[]";
      await navigator.clipboard.writeText(data);
      alert();
    });

    armOneShotCheckbox(importCb, () => {
      const text = importBox.value.trim();
      if (!text) return;

      try {
        const parsed = JSON.parse(text);
        if (!Array.isArray(parsed)) throw new Error("Not an array");
        localStorage.setItem(getSessionKey(), JSON.stringify(parsed));

        const ids = [];
        for (let i = 0; i < parsed.length; i++) ids.push(Number(parsed[i].id));
        saveOrder(ids);

        importBox.value = "";
        renderAllTimers();
        alert();
      } catch {
        alert("Invalid JSON. Paste only the array that starts with [ and ends with ].");
      }
    });

    // -------- Initial render + midnight schedule --------
    maybeResetCountersForNewDay();
    scheduleMidnightCounterReset();

    renderAllTimers();
  </script>

</body>
</html>